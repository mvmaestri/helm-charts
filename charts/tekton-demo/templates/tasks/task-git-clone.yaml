{{ $application := default dict .Values.application }}
{{ $cluster := default dict .Values.cluster }}
{{ $config := default dict .Values.config }}
{{- if .Values.repositories }}
{{- range $repo := .Values.repositories }}
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: git-{{ $repo.id }}
  labels:
    app.kubernetes.io/version: "0.2"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: git
    tekton.dev/displayName: "git clone"
spec:
  description: >-
    These Tasks are Git tasks to work with repositories used by other tasks
    in your Pipeline.
    The git-clone Task will clone a repo from the provided url into the
    output Workspace. By default the repo will be cloned into the root of
    your Workspace. You can clone into a subdirectory by setting this Task's
    subdirectory param.
  workspaces:
    - name: output
      description: The git repo will be cloned onto the volume backing this workspace
  params:
    - name: revision
      description: git revision to checkout (branch, tag, sha, refâ€¦)
      type: string
      default: ""
    - name: refspec
      description: (optional) git refspec to fetch before checking out revision
      default: ""
    - name: submodules
      description: defines if the resource should initialize and fetch the submodules
      type: string
      default: "true"
    - name: depth
      description: performs a shallow clone where only the most recent commit(s) will be fetched
      type: string
      default: "1"
    - name: sslVerify
      description: defines if http.sslVerify should be set to true or false in the global git config
      type: string
      default: "true"
    - name: subdirectory
      description: subdirectory inside the "output" workspace to clone the git repo into
      type: string
      default: ""
    - name: deleteExisting
      description: clean out the contents of the repo's destination directory (if it already exists) before trying to clone the repo there
      type: string
      default: "true"
    - name: httpProxy
      description: git HTTP proxy server for non-SSL requests
      type: string
      default: ""
    - name: httpsProxy
      description: git HTTPS proxy server for SSL requests
      type: string
      default: ""
    - name: noProxy
      description: git no proxy - opt out of proxying HTTP/HTTPS requests
      type: string
      default: ""
    - name: ref
      type: string
      description: ref from the event listener payload, e.g refs/heads/release/1.0.0
    - name: revision-type
      type: string
    - name: revision-name
      type: string
    - name: revision-short
      type: string
    - name: revision-alias
      type: string
    - name: repourl
      type: string
      description: url of the repository, from the event listener payload e.g body.repository.html_url (it can be overwritten)
    - name: reponame
      type: string
      description: repo name from event listener payload
    - name: repofullname
      type: string
      description: includes user or organization
    - name: author
      type: string
      description: username from event listener payload head_commit.author.username
    - name: message
      type: string
      description: commit message from event listener payload head_commit.message
  results:
    - name: commit
      description: The precise commit SHA that was fetched by this Task
    - name: url
      description: The precise URL that was fetched by this Task
    - name: cluster
      description: apps cluster url
    - name: ref
      description: reference
    - name: revision
      description: unique id from git head commit
    - name: revision-short
      description: unique id from git head commit short version
    - name: revision-type
      description: Contains the type of branch - feature, release,...
    - name: revision-name
      description: Contains the name of the branch without the type, ie. omitting the first slash
    - name: full-revision-name
      description: Contains the name of the branch without the type, ie. omitting the first slash
    - name: repourl
      description: repository url from github payload
    - name: repofullname
      description: full name user-org/reponame from github
  steps:
    - name: clone
      image: gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.17.1
      script: |
        #!/bin/sh
        set -eu -o pipefail
        CHECKOUT_DIR="$(workspaces.output.path)/$(params.subdirectory)"
        cleandir() {
          # Delete any existing contents of the repo directory if it exists.
          #
          # We don't just "rm -rf $CHECKOUT_DIR" because $CHECKOUT_DIR might be "/"
          # or the root of a mounted volume.
          if [[ -d "$CHECKOUT_DIR" ]] ; then
            # Delete non-hidden files and directories
            rm -rf "$CHECKOUT_DIR"/*
            # Delete files and directories starting with . but excluding ..
            rm -rf "$CHECKOUT_DIR"/.[!.]*
            # Delete files and directories starting with .. plus any other character
            rm -rf "$CHECKOUT_DIR"/..?*
          fi
        }
        if [[ "$(params.deleteExisting)" == "true" ]] ; then
          cleandir
        fi
        test -z "$(params.httpProxy)" || export HTTP_PROXY=$(params.httpProxy)
        test -z "$(params.httpsProxy)" || export HTTPS_PROXY=$(params.httpsProxy)
        test -z "$(params.noProxy)" || export NO_PROXY=$(params.noProxy)

        # condition to clone all repos that are not coming from payload
        # based on the config.deployment.stragegy
        echo Comparing {{ $repo.name }} == $(params.reponame)
        if [[ "{{ $repo.name }}" == "$(params.reponame)" ]]; then
          # coming from payload, so clone repository from payload
          echo Cloning $(params.repourl) $(params.ref) $(params.revision) from event listener payload
          /ko-app/git-init \
            -url "$(params.repourl)" \
            -revision "$(params.revision)" \
            -path "$CHECKOUT_DIR" \
            -sslVerify="$(params.sslVerify)" \
            -submodules="$(params.submodules)" \
            -depth "$(params.depth)"

          printf %s "$(params.repourl)" > $(results.url.path)
        else
          # different repo from the payload, so clone all the ones that are not from payload
        {{- if not $config.deployment.strategy.revisionMatch }}
            echo Deployment strategy revisionMatch is {{ $config.deployment.strategy.revisionMatch }}
            echo Cloning {{ $repo.url }} {{ $config.deployment.strategy.latest.from }}
            /ko-app/git-init \
              -url "{{ $repo.url }}" \
              -revision "{{ $config.deployment.strategy.latest.from }}" \
              -path "$CHECKOUT_DIR" \
              -sslVerify="$(params.sslVerify)" \
              -submodules="$(params.submodules)" \
              -depth "$(params.depth)"
        
            printf %s "{{ $repo.url }}" > $(results.url.path)
        {{- end }}
        fi

        cd "$CHECKOUT_DIR"
        RESULT_SHA="$(git rev-parse HEAD)"
        EXIT_CODE="$?"
        if [ "$EXIT_CODE" != 0 ] ; then
          exit $EXIT_CODE
        fi

        printf %s "$RESULT_SHA" >> $(results.commit.path)

    - name: variables
      image: registry.redhat.io/openshift4/ose-cli:latest
      resources: {}
      script: |
        #!/bin/sh
        # todo: get cluster url
        if [[ "{{ $repo.name }}" == "$(params.reponame)" ]]; then
          # from event listener payload
          echo $(params.ref) > $(results.ref.path)
          echo $(params.revision) | sed 's/ *$//g' > $(results.revision.path)
          echo $(params.repourl) > $(results.repourl.path)
          echo $(params.repofullname) > $(results.repofullname.path)
          printf %s "$(params.revision-name)" > $(results.revision-name.path)
          printf %s "$(params.revision-type)" > $(results.revision-type.path)
          printf %s "$(params.revision-short)" > $(results.revision-short.path)
          printf %s "$(params.revision-alias)" > $(results.revision-alias.path)
          if [ "$(cat /tekton/results/revision-type)" == "develop" ]; then
            printf %s "develop" > $(results.revision-name.path)
          fi
  
          echo ref $(cat $(results.ref.path))
          echo revision $(cat $(results.revision.path))
          echo revision-alias $(cat $(results.revision-alias.path))
          echo revision-short $(cat $(results.revision-short.path))
          echo revision-type $(cat $(results.revision-type.path))
          echo revision-name $(cat $(results.revision-name.path))
          echo author $(params.author)
          echo commit: $(params.message)
        else
          # overwriten from inputs
          if [ "{{ $config.deployment.strategy.latest.from }}" == "develop" ]; then
            printf %s "develop" > $(results.revision-name.path)
            printf %s "develop" > $(results.revision-type.path)
          else
            printf %s "{{ $config.deployment.strategy.latest.from }}" | awk -F "/" '{ printf "%s", $1 > $(results.revision-type.path) }'
            printf %s "{{ $config.deployment.strategy.latest.from }}" | awk -F "/" '{ printf "%s", $2 > $(results.revision-name.path) }'
          fi
          echo repo-id: {{ $repo.id }}
          echo revision-type $(cat $(results.revision-type.path))
          echo revision-name $(cat $(results.revision-name.path))
        fi

    - name: validate
      image: {{ $repo.tasks.build.runtime }}
      resources: {}
      workingDir: /workspace/output
      script: |
        #!/bin/sh

        ref=$(cat /tekton/results/ref)
        revisionType=$(cat /tekton/results/revision-type)
        revisionName=$(cat /tekton/results/revision-name)
        printf %s "$(git rev-parse HEAD)" > $(results.revision.path)
        printf %s "$(git rev-parse --short HEAD)" > $(results.revision-short.path)

        # verify if it's not a tag webhook event
        if [[ $ref == *"refs/tags/"* ]]; then
          echo "This is a tag commit. Not building."
          exit 1
        fi

        if [ "$revisionType" == "release" ] || [ "$revisionType" = "hotfix" ] || [ "$revisionType" = "patch" ] || [ "$revisionType" == "feature" ] || [ "$revisionType" = "develop" ]; then
          exit 0
        else
          echo "Branch $revisionType is not supported as part of git flow implementation"
          exit 1
        fi

      {{- if $repo.tasks.validate.tagExists }}
        git fetch --all --tags > /dev/null 2>&1
        if git rev-parse -q --verify "refs/tags/$revisionName" >/dev/null; then
            echo "Tag $revisionName already exists"
            exit 1
        fi
      {{- end }}

      {{- if $repo.tasks.validate.fileExists }}
        ls -ls
        {{- range $i, $file := $repo.tasks.validate.fileExists }}
        file{{ $i }}={{ $repo.tasks.build.context }}/{{ $file }}
        if [ ! -f $file{{ $i }} ]; then
            echo "Missing $file{{ $i }}"
            exit 1 
        fi
        {{- end }}
      {{- end }}

      {{- if $repo.tasks.validate.npmVersion }}

        before=$(cat {{ $repo.tasks.build.context }}/package.json \
        | grep version \
        | head -1 \
        | awk -F: '{ print $2 }' \
        | sed 's/[",]//g')
        
        before=$(echo -e $before)
        # hack for first version to be upgraded as major
        if [ "$before" == "0.0.0" ]; then
          importance=major
        else
          importance=minor
        fi

        if [ "$(cat /tekton/results/revision-type)" == "release" ]; then
          version=$(npm version $importance)
          if [ "$version" = "v$(cat /tekton/results/revision-name)" ]; then
            echo Version is OK
            exit 0
          else
            echo "Version from package.json ($before) does not match with branch $(cat /tekton/results/revision-type)/$(cat /tekton/results/revision-name)"
            exit 1
          fi
        elif [ "$(cat /tekton/results/revision-type)" == "patch" ] || [ "$(cat /tekton/results/revision-type)" = "hotfix" ]; then
          version=$(npm version patch)
          if [ "$version" = "v$(cat /tekton/results/revision-name)" ]; then
            echo "Version from package.json upgraded to $version"
          else
            echo "Version from package.json ($before) does not match with branch $(cat /tekton/results/revision-type)/$(cat /tekton/results/revision-name)"
            exit 1
          fi
        else
          echo "Skipping npm version upgrade since we are in a $(cat /tekton/results/revision-type) branch"
          exit 0
        fi
      {{- end }}

        echo OK
      securityContext:
        runAsUser: 0

{{- end }}
{{- end }}